---
templateKey: blog-post
title: 이벤트 루프
description: 이벤트 루프 설명 개념 설명, 매크로태스크, 마이크로태스크, 렌더, 태스크 관련 팁 정리.
tags:
  - JavaScript
  - Performance
date: 2023-09-19T08:50:46.093Z
updated: 2023-09-19T08:50:46.102Z
featuredimage: https://res.cloudinary.com/dftuawd1d/image/upload/f_auto,q_auto/c_fit,h_240,w_360/v1695118069/blog/people-circle_bx43a4.png
---
이벤트 루프는 자바스크립트와 브라우저 동작의 핵심적인 개념이다.

## 자바스크립트 엔진

자바스크립트는 **싱글 스레드, 논블로킹** 언어다. 싱글 스레드는 하나의 힙(Heap) 영역과 하나의 콜 스택(Call Stack)을 갖는다. 하나의 콜 스택을 갖는다는 의미는 한 번에 하나의 일만 할 수 있다는 것이다.

* **콜 스택**: 함수의 호출들은 스택을 형성한다. 스택이기 때문에 선입선출로 동작한다.
* **힙**: 객체는 힙에 할당된다. 힙은 단순히 메모리의 큰 영역을 지칭하는 용어다.

![자바스크립트 엔진 구성](https://res.cloudinary.com/dftuawd1d/image/upload/v1695113887/blog/js-engine_uy7mqb.png)

메인 스레드는 싱글 스레드로 아래와 같은 작업들을 한번에 하나씩 처리한다. 

* HTML이나 CSS 파싱
* 사용자 인터랙션 처리
* 자바스크립트 컴파일 및 실행
* 네트워크 데이터 수신
* 렌더 (스타일, 레이아웃, 페인트)

또한 작업들은 순차적으로 처리된다는 특징이 있다(**동기식, synchronous**). 다시 말해 이전 작업이 완료된 후에야 다음 작업을 진행할 수 있다. 

잠깐만, 동기식이라고? 그런데 브라우저에는 아래 예시처럼 비동기 작업이 수없이 많지 않던가..

* `XMLHttpRequest` 또는 `fetch`를 통한 네트워크 데이터 로드  
* `addEventListener`를 통한 이벤트 응답  
* `setTimeout` 또는 `setInterval`과 같은 타이머  

## 비동기 작업은 어떻게 처리될까?

비동기 작업이 진행 중에도 자바스크립트 앱은 멈추지 않고 사용자 인터랙션 핸들링처럼 다른 작업들도 처리할 수 있어야 할 것이다. 즉, 비동기 + 논블로킹(Non-blocking)으로 동작해야 한다.

실제 비동기 작업을 처리하는 것은 자바스크립트 엔진이 아니라 브라우저다. 브라우저 내부의 멀티 스레드인 Web APIs에서 비동기 + 논블로킹으로 처리된다. 그리고 이벤트 루프는 콜 스택에 지속적으로 작업을 전달해주는 역할을 한다. 자바스크립트 엔진은 단지 콜 스택에 쌓인 작업을 계속 실행할 뿐이다.

예를 들어 `setTimeout(callback, 500)`을 사용하면 Web APIs가 500ms를 카운트한 후에 해당 콜백을 태스크 큐에 넣는다. 이벤트 루프는 큐에 대기중인 태스크가 있는 것을 확인하고, 콜 스택이 비어있을 때 태스크를 콜 스택으로 보낸다. 그러니 메인 스레드는 500ms 동안 다른 일을 하다가 콜 스택에 태스크가 들어오면 처리하면 된다.

![이벤트 루프 다이어그램](https://res.cloudinary.com/dftuawd1d/image/upload/f_auto,q_auto/v1695117478/blog/event-loop-simple_xpp7ij.png)

> 자바스크립트는 싱글 스레드지만 웹 워커(Web Worker)를 사용하여 별도의 백그라운드 스레드에서 코드를 병렬로 실행할 수 있다. 단, 웹 워커는 돔에 접근할 수 없기 때문에 무거운 연산이 필요한 경우에 주로 사용된다.

## 이벤트 루프

이벤트 루프(Event Loop)는 콜 스택과 태스크 큐 사이에서 콜 스택으로 작업(태스크 혹은 렌더)을 전달하는 역할만 한다. 그리고 이것을 무한 반복한다.

이벤트 루프는 매 턴마다 태스크 큐에서 태스크를 선택하거나 렌더할 지 여부를 결정한다. 구체적으로는 아래 단계를 반복 수행한다.

1. 매크로태스크 큐에 태스크가 있으면 태스크를 하나 처리한다.
2. 마이크로태스 큐에 태스크가 있으면 모든 태스크를 처리한다.
3. 렌더가 필요한 지 확인하여 렌더한다.
4. 1로 돌아간다.



![이벤트 루프 다이어그램](https://res.cloudinary.com/dftuawd1d/image/upload/f_auto,q_auto/v1695113888/blog/event-loop-full_yb1iym.png)



### 매크로태스크와 마이크로태스크

태스크는 매크로태스크(macro task, 혹은 그냥 태스크)와 마이크로태스크(microtask)로 나뉜다. 마이크로태스크가 매크로태스크보다 높은 우선순위를 갖는다. 이벤트 루프의 턴을 기준으로 다음 매크로태스크를 처리하기 전에 마이크로태스크 큐에 쌓인 모든 태스크를 전부 처리한다. 반면 매크로태스크는 큐에 적재된 것이 하나씩 처리된다.

매크로태스크 예로는 비동기로 동작하는 `addEventListener`, `setTimeout`, `setInterval`, `fetch`의 콜백 함수가 있다. Web APIs에서 콜백 함수를 매크로태스크 큐에 적재한다.

마이크로태스크는 프로미스 핸들러인 `.then/catch/finally`(혹은 `async/await`) 콜백 함수가 해당한다. 또는 직접적으로 표준 API인 `queueMicrotask` 메서드를 사용하여 마이크로태스크 큐에 넣을 수도 있다.

### 렌더

렌더(render)는 DOM과 CSS를 픽셀로 변환하여 사용자 화면에 나타내는 작업을 한다. 렌더 작업이 완료된 후에 생성되는 것을 **프레임**(frame)이라고 한다. DOM이나 CSS 스타일을 편집하면 브라우저는 이전 프레임이 유효하지 않다고 판단하고 새로운 프레임을 만들게 된다.

렌더를 완료하려면 일반적으로 3가지 주요 단계가 있다.

1. **스타일** - 시각 요소에 CSS 색상, 글꼴 및 기타 스타일 속성을 할당한다.
2. **레이아웃** - 좌표계에 시각 요소를 배치한다.
3. **페인트** - 스타일과 위치가 정해진 시각 요소를 그린다.

## 0의 지연 시간
`setTimeout`의 지연 시간에 0ms를 지정하고 호출하더라도 콜백 함수는 즉시 실행되지 않는다. 지정해준 지연 시간은 요청을 처리하기 전에 대기할 "최소" 시간을 의미할 뿐이다.

setTimeout의 콜백은 마이크로태스크에 적재될 것이고 이벤트 루프의 처리 순서에 따라 콜 스택으로 보내져 실행될 것이다. 실제 실행되는 시점은 콜 스택과 태스크 큐에 대기 중인 다른 태스크 상황에 따라 달라지게 되는 것이다.


## 태스크는 작게

메인 스레드는 한 번에 하나씩, 순차적으로 태스크 혹은 렌더링을 처리할 수 있다. 그래서 일반적으로 태스크를 처리하는 시간이 짧아야 브라우저가 렌더링 단계를 더 빨리 호출하여 사용자에게 프레임을 전달할 수 있다. 큰 태스크를 작게 유지하거나 쪼개는 것이 좋은 이유다. 이벤트 루프를 막지 않고 돌아갈 수 있게 해줘야 한다.

예를 들어 자바스크립트 실행 도중 돔의 레이아웃을 계산하는 경우가 있는데, 이를 강제 리플로우(Forced Reflow)라고 하며 태스크를 무겁게 하는 요인이다. 관련하여 [강제 리플로우 방지](https://cozyzoey.kr/blog/preventing-forced-reflow/)라는 포스트를 작성하였다. 

참고로 60fps 디스플레이 기기에서 각 프레임의 예산은 16ms(1초/60 = 16.66ms)가 조금 넘고, 브라우저가 필요한 다른 기타 작업을 고려하면 모든 작업이 [**10ms** 이내에 완료](https://web.dev/rendering-performance/#60fps-and-device-refresh-rates)되어야 한다. 태스크가 이보다 오래 걸리면 프레임 레이트가 떨어지고 화면이 끊기는 현상이 생길 수 있는 것이다.

## 결론
자바스크립트 엔진은 동기식, 논블로킹으로 동작하기 때문에 브라우저상의 비동기 동작을 처리할 수 있는 장치가 필요하다. 실제 비동기 동작을 처리하는 것은 Web APIs이며, 이벤트 루프는 둘 사이에서 자바스크립트 엔진의 콜 스택으로 태스크를 옮겨주는 역할을 한다.

자바스크립트 엔진의 메인 스레드는 싱글 스레드로써 태스크나 렌더 작업 하나씩만 순차적으로 처리할 수 있다. 그러니 태스크를 작게 유지하거나 `setTimeout` 비동기 함수를 사용해서 다른 태스크로 쪼개어 이벤트 루프를 막지 않는 것이 좋다.


## 참조
- [concept event loop in category javascript](https://livebook.manning.com/concept/javascript/event-loop)
- [이벤트 루프](https://developer.mozilla.org/ko/docs/Web/JavaScript/Event_loop)
- [Event Loop Fundamentals
](https://webperf.tips/tip/event-loop/)
- [자바스크립트 이벤트 루프 동작 구조 & 원리 끝판왕](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
- [60fps and Device Refresh Rates](https://web.dev/rendering-performance/#60fps-and-device-refresh-rates)